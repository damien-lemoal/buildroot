#!/bin/bash

cmd="$(basename "$0")"

FUNC="pci_epf_nvme.0"
subsys="${FUNC}.nqn"
nrioq=$(nproc)
debug=0
mmio=0
bufferedio=0
model="Linux-pci-epf"
mdts="128"

transport="loop"
looppath=""
sched=""

tcpaddr=""
tcpport=""

ctrlopts=""

function exit_failed()
{
	echo "$1"
	exit 1
}

function usage()
{
	echo "Usage:"
	echo "    ${cmd} [-h | --help]"
	echo "    ${cmd} [options] start"
	echo "    ${cmd} stop"
	echo "Start command options:"
	echo "  --debug-epf               : Turn on nvme epf debug messages"
	echo "  --debug-nvme              : Turn on nvme fabrics debug messages"
	echo "  --debug-pci               : Turn on pci controller debug messages"
	echo "  --debug                   : Turn on epf, nvme and pci kernel debug messages"
	echo "  --disable-dma             : Disable use of DMA (use mmio transfers)"
	echo "  --model <str>             : Use <str> as device model name"
	echo "                              (default: Linux-pci-epf)"
	echo "  --mdts <size (KB)>        : Set maximum command transfer size"
	echo "                              (default 128 KB)"
	echo "  --buffered-io             : Used buffered IOs on the target"
	echo "                              (default: no)."
	echo "  --nrioq <num>             : Set maximum number of I/O queues"
	echo "                              (default: number of CPUs)."
	echo "  --loop <path>             : Use file or block device with nvme_loop target"
	echo "                              (default: use null_blk and /dev/nullb0)."
	echo "  --tcp <addr> <port> <nqn> : Connect to nvme_tcp target."
	echo "  --sched <sched>           : Use the <sched> I/O scheduler for the loop device"
}

# Check options
while [ "${1#-}" != "$1" ]; do
	case "$1" in
	-h | --help)
		usage
		exit 0
		;;
	--debug-epf)
		debug_epf=1
		;;
	--debug-nvme)
		debug_nvme=1
		;;
	--debug-pci)
		debug_pci=1
		;;
	--debug)
		debug_epf=1
		debug_nvme=1
		debug_pci=1
		;;
	--disable-dma)
		mmio=1
		;;
	--model)
		shift
		model="$1"
		;;
	--mdts)
		shift
		mdts="$1"
		;;
	--buffered-io)
		bufferedio=1
		;;
	--nrioq)
		shift
		nrioq=$1
		;;
	--loop)
		transport="loop"
		shift
		looppath="$1"
		;;
	--sched)
		shift
		sched="$1"
		;;
	--tcp)
		transport="tcp"
		shift
		tcpaddr="$1"
		shift
		tcpport="$1"
		shift
		subsys="$1"
		;;
	-*)
		echo "Unknow option $1"
		exit 1
		;;
	esac
	shift
done

if [ "$1" == "" ]; then
	usage
	exit 1
fi

if [ "${transport}" != "loop" ] && [ "${transport}" != "tcp" ]; then
	echo "Unknown transport"
	exit 1
fi

if [ ${nrioq} -le 0 ]; then
	echo "Invalid maximum number of I/O queues."
	exit 1
fi

if [ "${looppath}" == "" ]; then
	modprobe null_blk \
		nr_devices=1 \
		submit_queues="$(nproc --all)" \
		gb=1024 max_sectors=2048 || \
		exit_failed "Load null_blk failed"
	looppath="/dev/nullb0"
fi

if [ "${sched}" != "" ]; then
	modprobe ${sched} || \
                exit_failed "Load ${sched} failed"
        echo "${sched}" > /sys/block/$(basename ${looppath})/queue/scheduler || \
                exit_failed "Set ${sched} failed"
fi

action="$1"

function nvme_setup_loop()
{
	local port="1"
	local ns="1"

	echo "Creating NVMe loop subsystem ${subsys}, target ${looppath}"

	echo "    Loading nvme_loop"
	modprobe nvme_loop || \
		exit_failed "Load nvme_loop failed"

	# Create the subsystem
	echo "    Creating subsystem ${subsys}"
	cd /sys/kernel/config/nvmet/subsystems
	mkdir "${subsys}"

	echo -n "${model}" > ${subsys}/attr_model
	echo 1 > ${subsys}/attr_allow_any_host
	echo ${nrioq} > ${subsys}/attr_qid_max

	# Create a namespace
	echo "    Creating namespace 1"
	nsdir="${subsys}/namespaces/${ns}"
	mkdir "${nsdir}"
	echo -n "${looppath}" > "${nsdir}/device_path"

	if [ "${bufferedio}" == "1" ]; then
		echo "    Enabling buffered IO"
		echo "1" > "${nsdir}/buffered_io" || \
			exit_failed "Enabling buffered IO failed"
	fi

	echo 1 > "${nsdir}/enable"

	# Create an NVMe port
	echo "    Creating port 1"
	cd /sys/kernel/config/nvmet/ports
	mkdir "${port}"
	echo -n "loop" > ${port}/addr_trtype

	ln -s /sys/kernel/config/nvmet/subsystems/${subsys} \
        	/sys/kernel/config/nvmet/ports/${port}/subsystems/${subsys}

	ctrlopts="transport=loop"
}

function nvme_teardown_loop()
{
	local port="1"
	local ns="1"
       	local portdir="/sys/kernel/config/nvmet/ports/${port}"
	local subsysdir="/sys/kernel/config/nvmet/subsystems/${subsys}"
	local nsdir="${subsysdir}/namespaces/${ns}"

	echo "Deleting NVMe loop subsystem ${subsys}, target ${looppath}"

	if [ -d "${nsdir}" ]; then
		echo 0 > "${nsdir}/enable"
	fi

       	if [ -d "${portdir}/subsystems/${subsys}" ]; then
       		rm /sys/kernel/config/nvmet/ports/${port}/subsystems/${subsys} || \
			exit_failed "Detach subsystem ${subsys} from port ${port} failed"
	fi

       	if [ -d "${portdir}" ]; then
       		rmdir /sys/kernel/config/nvmet/ports/${port} || \
			exit_failed "Delete port ${port} failed"
	fi

	if [ -d "${nsdir}" ]; then
		rmdir "${nsdir}" || \
			exit_failed "Delete subsystem ${subsys} namespace ${ns} failed"
	fi

	if [ -d "${subsysdir}" ]; then
		rmdir "/sys/kernel/config/nvmet/subsystems/${subsys}" || \
			exit_failed "Delete subsystem ${subsys} failed"
	fi

	echo "    Removing nvme_loop"
	rmmod nvme_loop || \
		exit_failed "Remove nvme_loop failed"
	echo "    Removing nvmet"
	rmmod nvmet || \
		exit_failed "Remove nvmet failed"
}

function nvme_setup_tcp()
{
	echo "Connecting to NVMe tcp subsystem ${subsys}, addr ${tcpaddr}:${tcpport}"

	echo "    Loading nvme_tcp"
	modprobe nvme_tcp|| \
		exit_failed "Load nvme_tcp failed"

	ctrlopts="transport=tcp,traddr=${tcpaddr},trsvcid=${tcpport}"
}

function nvme_teardown_tcp()
{
	echo "    Removing nvme_tcp"
	rmmod nvme_tcp || \
		exit_failed "Remove nvme_tcp failed"
	echo "    Removing nvmet"
	rmmod nvmet || \
		exit_failed "Remove nvmet failed"
}

function nvme_epf_start()
{
	# Load modules
	echo "Loading pci-epf-nvme"
	modprobe pci-epf-nvme || \
		exit_failed "Load pci-epf-nvme failed"

	# Enable pr_debug
	if [ "${debug_epf}" == "1" ]; then
		echo "Enabling epf debug"
		echo 8 > "/proc/sys/kernel/printk"
		echo -n 'module pci_epf_nvme +p;' > \
			"/sys/kernel/debug/dynamic_debug/control"
	fi

	if [ "${debug_nvme}" == "1" ]; then
		echo "Enabling nvme debug"
		echo 8 > "/proc/sys/kernel/printk"
		echo -n 'module nvmet +p;' > \
			"/sys/kernel/debug/dynamic_debug/control"
		echo -n 'module nvme_loop +p;' > \
			"/sys/kernel/debug/dynamic_debug/control"
	fi

	if [ "${debug_pci}" == "1" ]; then
		echo "Enabling pci debug"
		echo 8 > "/proc/sys/kernel/printk"
		echo -n 'file drivers/pci/controller/dwc/pcie-dw-rockchip.c +p;' > \
                        "/sys/kernel/debug/dynamic_debug/control"
                echo -n 'file drivers/pci/controller/dwc/pcie-designware.c +p;' > \
                        "/sys/kernel/debug/dynamic_debug/control"
                echo -n 'file drivers/pci/controller/dwc/pcie-designware-ep.c +p;' > \
                        "/sys/kernel/debug/dynamic_debug/control"
	fi

	# Setup the NVMe fabrics host controller.
	if [ "${transport}" == "loop" ]; then
		nvme_setup_loop || \
			exit_failed "Setup NVMe loop controller failed"
	else
		nvme_setup_tcp || \
			exit_failed "Setup NVMe tcp controller failed"
	fi

	# Check controller
	cd /sys/kernel/config/pci_ep || \
		exit_failed "Missing PCI-EP"

	controller="$(find controllers -name "*pcie*")"
	if [ -z "${controller}" ]; then
		exit_failed "PCI EP Controller not found"
	fi

	# Setup the NVMe endpoint function
	echo "Creating NVMe endpoint function ${FUNC}..."
	mkdir "functions/pci_epf_nvme/${FUNC}" || \
		exit_failed "Create ${FUNK} failed"
	sleep 0.5

	echo "    Set Vendor ID to Sandisk Corp (0x15b7)"
	echo 0x15b7 > "functions/pci_epf_nvme/${FUNC}/vendorid" || \
		exit_failed "Set vendorid failed"

	echo "    Set Device ID to dummy 0x5fff"
	echo 0x5fff > "functions/pci_epf_nvme/${FUNC}/deviceid" || \
		exit_failed "Set deviceid failed"

	echo "    Set MSIX interrupts"
	echo 32 > "functions/pci_epf_nvme/${FUNC}/msix_interrupts" || \
		exit_failed "Set msix_interrupts failed"

	echo "    Set MSI interrupts"
	echo 32 > "functions/pci_epf_nvme/${FUNC}/msi_interrupts" || \
		exit_failed "Set msi_interrupts failed"

	if [ "${mmio}" == "1" ]; then
		echo "    Disabling DMA"
		echo "0" > "functions/pci_epf_nvme/${FUNC}/nvme/dma_enable" || \
			exit_failed "Disable DMA failed"
	fi

	echo "    Set MDTS"
	echo "${mdts}" > "functions/pci_epf_nvme/${FUNC}/nvme/mdts_kb" || \
		exit_failed "Set MDTS failed"

	echo "    Set NVMe controller options"
	echo -n "${ctrlopts},nqn=${subsys},nr_io_queues=${nrioq}" > \
		"functions/pci_epf_nvme/${FUNC}/nvme/ctrl_opts" || \
		exit_failed "Set NVMe controller options failed"

	# Start the NVMe endpoint function
	echo "Attaching NVMe endpoint function to PCI EP controller ${controller}..."
	ln -s "functions/pci_epf_nvme/${FUNC}" "${controller}/" || \
		exit_failed "Attach function ${FUNC} to controller failed"

	echo "Starting the PCI controller..."
	echo 1 > "${controller}/start" || \
		exit_failed "Start the PCI EP controller failed"
}

function nvme_epf_stop()
{
	# Check controller
	cd /sys/kernel/config/pci_ep || \
		exit_failed "Missing PCI-EP"

	controller="$(find controllers -name "*pcie*")"
	if [ -z "${controller}" ]; then
		exit_failed "PCI EP Controller not found"
	fi

	# Check target transport
	loop=$(cat "functions/pci_epf_nvme/${FUNC}/nvme/ctrl_opts" | \
		grep -c loop)
	if [ "${loop}" == "1" ]; then
		transport="loop"
	else
		transport="tcp"
	fi

	echo "Stopping the PCI controller"
	echo 0 > "${controller}/start" || \
		exit_failed "Stop the PCI EP controller failed"

	echo "Detaching NVMe endpoint function from PCI EP controller ${controller}..."
	rm "${controller}/${FUNC}" || \
		exit_failed "Detach function ${FUNC} from controller failed"

	echo "Destroying NVMe endpoint function ${FUNC}..."
	rmdir "functions/pci_epf_nvme/${FUNC}" || \
		exit_failed "Remove ${FUNC} failed"

	rmmod pci-epf-nvme

	if [ "${transport}" == "loop" ]; then
		nvme_teardown_loop
	else
		nvme_teardown_tcp
	fi
}

case "${action}" in
start)
	nvme_epf_start
	;;
stop)
	nvme_epf_stop
	;;
*)
	echo "Unknow action ${action}"
	exit 1
	;;
esac

