From b4cab33af059ac7f2254da8e849b0388353ee496 Mon Sep 17 00:00:00 2001
From: Damien Le Moal <dlemoal@kernel.org>
Date: Thu, 13 Apr 2023 17:46:30 +0900
Subject: [PATCH 39/51] PCI: rockchip: Implement the map_offset endpoint
 operation

The rockchip PCIe endpoint controller handles PCIe transfers addresses
by masking the programmed PCI address lower bits and using the same
amount of lower bits from the CPU address space used for the mapping.
This means that when preparing a PCI address mapping, an endpoint
function driver must use a correct offset into the CPU region allocated
with pci_epc_mem_alloc_addr() in order for the transfers to reach the
correct PCI address on the RC.

Implement the map_offset endpoint controller operation to allow this.
The offset is calculated by determining the number of lower bits
changing over the range of PCI address of a mapping. That is, the offset
computation depends on both the start PCI address and the size of the
mapping.

Signed-off-by: Damien Le Moal <dlemoal@kernel.org>
---
 drivers/pci/controller/pcie-rockchip-ep.c | 26 ++++++++++++++++++-----
 1 file changed, 21 insertions(+), 5 deletions(-)

diff --git a/drivers/pci/controller/pcie-rockchip-ep.c b/drivers/pci/controller/pcie-rockchip-ep.c
index caecee449e3e..02ad229dda4c 100644
--- a/drivers/pci/controller/pcie-rockchip-ep.c
+++ b/drivers/pci/controller/pcie-rockchip-ep.c
@@ -63,17 +63,22 @@ static void rockchip_pcie_clear_ep_ob_atu(struct rockchip_pcie *rockchip,
 			    ROCKCHIP_PCIE_AT_OB_REGION_DESC1(region));
 }
 
+static int rockchip_pcie_ep_ob_atu_num_bits(struct rockchip_pcie *rockchip,
+					    u64 pci_addr, size_t size)
+{
+	int num_pass_bits = fls64(pci_addr ^ (pci_addr + size - 1));
+
+	return max(num_pass_bits, 8);
+}
+
 static void rockchip_pcie_prog_ep_ob_atu(struct rockchip_pcie *rockchip, u8 fn,
 					 u32 r, u64 cpu_addr, u64 pci_addr,
 					 size_t size)
 {
-	u64 sz = 1ULL << fls64(size - 1);
-	int num_pass_bits = ilog2(sz);
+	int num_pass_bits =
+		rockchip_pcie_ep_ob_atu_num_bits(rockchip, pci_addr, size);
 	u32 addr0, addr1, desc0;
 
-	if (num_pass_bits < 8)
-		num_pass_bits = 8;
-
 	addr0 = ((num_pass_bits - 1) & PCIE_CORE_OB_REGION_ADDR0_NUM_BITS) |
 		(lower_32_bits(pci_addr) & PCIE_CORE_OB_REGION_ADDR0_LO_ADDR);
 	addr1 = upper_32_bits(pci_addr);
@@ -231,6 +236,16 @@ static inline u32 rockchip_ob_region(phys_addr_t addr)
 	return (addr >> ilog2(SZ_1M)) & 0x1f;
 }
 
+static ssize_t rockchip_pcie_ep_map_offset(struct pci_epc *epc, u8 fn, u8 vfn,
+					   u64 pci_addr, size_t size)
+{
+	struct rockchip_pcie_ep *ep = epc_get_drvdata(epc);
+	int num_bits =
+		rockchip_pcie_ep_ob_atu_num_bits(&ep->rockchip, pci_addr, size);
+
+	return pci_addr & ((1UL << num_bits) - 1);
+}
+
 static int rockchip_pcie_ep_map_addr(struct pci_epc *epc, u8 fn, u8 vfn,
 				     phys_addr_t addr, u64 pci_addr,
 				     size_t size)
@@ -453,6 +468,7 @@ static const struct pci_epc_ops rockchip_pcie_epc_ops = {
 	.write_header	= rockchip_pcie_ep_write_header,
 	.set_bar	= rockchip_pcie_ep_set_bar,
 	.clear_bar	= rockchip_pcie_ep_clear_bar,
+	.map_offset	= rockchip_pcie_ep_map_offset,
 	.map_addr	= rockchip_pcie_ep_map_addr,
 	.unmap_addr	= rockchip_pcie_ep_unmap_addr,
 	.set_msi	= rockchip_pcie_ep_set_msi,
-- 
2.39.2

