From 5222add2f95e68bb9349eba4b763b85dd072bb6b Mon Sep 17 00:00:00 2001
From: Damien Le Moal <dlemoal@kernel.org>
Date: Thu, 13 Apr 2023 14:45:40 +0900
Subject: [PATCH 33/51] PCI: endpoint: Introduce pci_epc_map_offset()

Introduce the function pci_epc_map_offset() to allow endpoint function
drivers to obtain the offset into a CPU address region to use when
mapping the region to PCI address space.

The map_offset endpoint controller operation is introduced for
defining per controller computation of the offset. This operation is
optional: controllers that do not have any CPU address alignement
constraint for a PCI address mapping do not need to implement the
map_offset method. For such controller, pci_epc_map_offset() returns 0.

Signed-off-by: Damien Le Moal <dlemoal@kernel.org>
---
 drivers/pci/endpoint/pci-epc-core.c | 30 +++++++++++++++++++++++++++++
 include/linux/pci-epc.h             |  6 ++++++
 2 files changed, 36 insertions(+)

diff --git a/drivers/pci/endpoint/pci-epc-core.c b/drivers/pci/endpoint/pci-epc-core.c
index fb2690468c0c..ed60ba94f8f9 100644
--- a/drivers/pci/endpoint/pci-epc-core.c
+++ b/drivers/pci/endpoint/pci-epc-core.c
@@ -439,6 +439,36 @@ void pci_epc_unmap_addr(struct pci_epc *epc, u8 func_no, u8 vfunc_no,
 }
 EXPORT_SYMBOL_GPL(pci_epc_unmap_addr);
 
+/**
+ * pci_epc_map_offset() - Get CPU address offset for a PCI address
+ * @epc: the EPC device on which address is allocated
+ * @func_no: the physical endpoint function number in the EPC device
+ * @vfunc_no: the virtual endpoint function number in the physical function
+ * @pci_addr: PCI address from which the transfer will start
+ * @size: the size of the PCI transfer
+ *
+ * Invoke the controller map_ofst method for a PCI address to obtain the offset
+ * into a CPU address region to map the PCI address.
+ */
+ssize_t pci_epc_map_offset(struct pci_epc *epc, u8 func_no, u8 vfunc_no,
+			   u64 pci_addr, size_t size)
+{
+	ssize_t ofst;
+
+	if (!pci_epc_check_func(epc, func_no, vfunc_no))
+		return -EINVAL;
+
+	if (!epc->ops->map_offset)
+		return 0;
+
+	mutex_lock(&epc->lock);
+	ofst = epc->ops->map_offset(epc, func_no, vfunc_no, pci_addr, size);
+	mutex_unlock(&epc->lock);
+
+	return ofst;
+}
+EXPORT_SYMBOL_GPL(pci_epc_map_offset);
+
 /**
  * pci_epc_map_addr() - map CPU address to PCI address
  * @epc: the EPC device on which address is allocated
diff --git a/include/linux/pci-epc.h b/include/linux/pci-epc.h
index 18a0c3dc1a95..b863593c470e 100644
--- a/include/linux/pci-epc.h
+++ b/include/linux/pci-epc.h
@@ -51,6 +51,8 @@ struct pci_epc_event_ops {
  * @write_header: ops to populate configuration space header
  * @set_bar: ops to configure the BAR
  * @clear_bar: ops to reset the BAR
+ * @map_offset: ops to get the offset to use into a CPU address region for
+ *		mapping a PCI address
  * @map_addr: ops to map CPU address to PCI address
  * @unmap_addr: ops to unmap CPU address and PCI address
  * @set_msi: ops to set the requested number of MSI interrupts in the MSI
@@ -75,6 +77,8 @@ struct pci_epc_ops {
 			   struct pci_epf_bar *epf_bar);
 	void	(*clear_bar)(struct pci_epc *epc, u8 func_no, u8 vfunc_no,
 			     struct pci_epf_bar *epf_bar);
+	ssize_t	(*map_offset)(struct pci_epc *epc, u8 func_no, u8 vfunc_no,
+			      u64 pci_addr, size_t size);
 	int	(*map_addr)(struct pci_epc *epc, u8 func_no, u8 vfunc_no,
 			    phys_addr_t addr, u64 pci_addr, size_t size);
 	void	(*unmap_addr)(struct pci_epc *epc, u8 func_no, u8 vfunc_no,
@@ -219,6 +223,8 @@ int pci_epc_set_bar(struct pci_epc *epc, u8 func_no, u8 vfunc_no,
 		    struct pci_epf_bar *epf_bar);
 void pci_epc_clear_bar(struct pci_epc *epc, u8 func_no, u8 vfunc_no,
 		       struct pci_epf_bar *epf_bar);
+ssize_t pci_epc_map_offset(struct pci_epc *epc, u8 func_no, u8 vfunc_no,
+			   u64 pci_addr, size_t size);
 int pci_epc_map_addr(struct pci_epc *epc, u8 func_no, u8 vfunc_no,
 		     phys_addr_t phys_addr,
 		     u64 pci_addr, size_t size);
-- 
2.39.2

