From fd7ed2b4aeb686e874727367d034a32abdc3a49f Mon Sep 17 00:00:00 2001
From: Damien Le Moal <dlemoal@kernel.org>
Date: Thu, 13 Apr 2023 17:46:30 +0900
Subject: [PATCH 40/44] PCI: rockchip: Implement the map_size endpoint
 controller operation

The rockchip PCIe endpoint controller handles PCIe transfers addresses
by masking the lower bits of the programmed PCI address and using the
same number of lower bits from the CPU address space used for the
mapping.

This means that when preparing a PCI address mapping, an endpoint
function driver must use a correct offset into the CPU region allocated
with pci_epc_mem_alloc_addr() in order for the transfers to reach the
correct PCI address on the RC, and a sufficient amount of memory must be
allocated to accomodate for this offset.

Implement the map_size endpoint controller operation to allow this
transparently from the endpoint function drivers. The offset is
calculated by determining the number of lower bits changing over the
range of RC PCI addresses of a mapping. That is, the offset computation
depends on both the start RC PCI address and the size of the mapping.

Signed-off-by: Damien Le Moal <dlemoal@kernel.org>
---
 drivers/pci/controller/pcie-rockchip-ep.c | 33 ++++++++++++++++++++---
 1 file changed, 29 insertions(+), 4 deletions(-)

diff --git a/drivers/pci/controller/pcie-rockchip-ep.c b/drivers/pci/controller/pcie-rockchip-ep.c
index 2c864951e831..0274448eb414 100644
--- a/drivers/pci/controller/pcie-rockchip-ep.c
+++ b/drivers/pci/controller/pcie-rockchip-ep.c
@@ -63,16 +63,22 @@ static void rockchip_pcie_clear_ep_ob_atu(struct rockchip_pcie *rockchip,
 			    ROCKCHIP_PCIE_AT_OB_REGION_DESC1(region));
 }
 
+static int rockchip_pcie_ep_ob_atu_num_bits(struct rockchip_pcie *rockchip,
+					    u64 pci_addr, size_t size)
+{
+	int num_pass_bits = fls64(pci_addr ^ (pci_addr + size - 1));
+
+	return max(num_pass_bits, 8);
+}
+
 static void rockchip_pcie_prog_ep_ob_atu(struct rockchip_pcie *rockchip, u8 fn,
 					 u32 r, u64 cpu_addr, u64 pci_addr,
 					 size_t size)
 {
-	int num_pass_bits = fls64(size - 1);
+	int num_pass_bits =
+		rockchip_pcie_ep_ob_atu_num_bits(rockchip, pci_addr, size);
 	u32 addr0, addr1, desc0;
 
-	if (num_pass_bits < 8)
-		num_pass_bits = 8;
-
 	addr0 = ((num_pass_bits - 1) & PCIE_CORE_OB_REGION_ADDR0_NUM_BITS) |
 		(lower_32_bits(pci_addr) & PCIE_CORE_OB_REGION_ADDR0_LO_ADDR);
 	addr1 = upper_32_bits(pci_addr);
@@ -230,6 +236,24 @@ static inline u32 rockchip_ob_region(phys_addr_t addr)
 	return (addr >> ilog2(SZ_1M)) & 0x1f;
 }
 
+static ssize_t rockchip_pcie_ep_map_size(struct pci_epc *epc, u8 fn, u8 vfn,
+					 u64 pci_addr, size_t size,
+					 phys_addr_t *phys_ofst)
+{
+	struct rockchip_pcie_ep *ep = epc_get_drvdata(epc);
+	phys_addr_t ofst;
+	int num_bits =
+		rockchip_pcie_ep_ob_atu_num_bits(&ep->rockchip, pci_addr, size);
+
+	ofst = pci_addr & ((1UL << num_bits) - 1);
+	if (size + ofst > SZ_1M)
+		return -ENOMEM;
+
+	*phys_ofst = ofst;
+
+	return ofst + size;
+}
+
 static int rockchip_pcie_ep_map_addr(struct pci_epc *epc, u8 fn, u8 vfn,
 				     phys_addr_t addr, u64 pci_addr,
 				     size_t size)
@@ -450,6 +474,7 @@ static const struct pci_epc_ops rockchip_pcie_epc_ops = {
 	.write_header	= rockchip_pcie_ep_write_header,
 	.set_bar	= rockchip_pcie_ep_set_bar,
 	.clear_bar	= rockchip_pcie_ep_clear_bar,
+	.map_size	= rockchip_pcie_ep_map_size,
 	.map_addr	= rockchip_pcie_ep_map_addr,
 	.unmap_addr	= rockchip_pcie_ep_unmap_addr,
 	.set_msi	= rockchip_pcie_ep_set_msi,
-- 
2.41.0

